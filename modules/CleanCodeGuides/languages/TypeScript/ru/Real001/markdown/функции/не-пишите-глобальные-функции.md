## Функции

### Не пишите глобальные функции

Загрязнение глобальных переменных — плохая практика в JavaScript, так как может породить конфликты с другой библиотекой, и пользователь вашего API не увидит ошибок, пока не получит исключение в продакшене. Давайте рассмотрим пример: 
что если вы хотите расширить стандартный метод Array JavaScript, имея метод `diff` который бы вычислял различие между двумя массивами? Вы должны были бы записать новую функцию в `Array.prototype`, но тогда она может войти в конфликт с другой библиотекой, которая пыталась сделать то же самое. Что если другая библиотека использовала метод `diff`, чтобы найти разницу между первым и последним элементами массива? В этом случае лучше использовать классы и просто сделать наследование от глобального `Array`.

**Плохо:**

```ts
declare global {
  interface Array<T> {
    diff(other: T[]): Array<T>;
  }
}
if (!Array.prototype.diff) {
  Array.prototype.diff = function <T>(other: T[]): T[] {
    const hash = new Set(other);
    return this.filter(elem => !hash.has(elem));
  };
}
```

**Хорошо:**

```ts
class MyArray<T> extends Array<T> {
  diff(other: T[]): T[] {
    const hash = new Set(other);
    return this.filter(elem => !hash.has(elem));
  };
}
```