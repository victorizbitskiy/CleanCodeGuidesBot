## **Классы**
### Предпочитайте композицию перед наследованием
Как верно замечено в [*Design Patterns*](https://ru.wikipedia.org/wiki/Design_Patterns) под авторством Банды Четырех \(Gang of Four\), когда это возможно, вы должны отдавать предпочтение композиции перед наследованием. Есть много хороших причин для использования наследования и много хороших причин для применения композиции. Главное, что если ваш ум инстинктивно идет путем наследования, подумайте, может быть композиция способна решить вашу проблему лучше. В ряде случаев это именно так.

Возможно вы задаетесь вопросом: "Когда я должен использовать наследование?". Это зависит от вашей проблемы, но вот конкретный список, когда наследование имеет больше смысла, чем композиция:

1. Ваше наследование представляет собой отношения "является разновидностью", а не "включает в себя" \(Человек->Животное против Пользователь->Детали_Пользователя\).
2. Вы можете повторно использовать код из базовых классов \(люди могут двигаться как и все животные\).
3. Вы хотите сделать глобальные изменения в производных классах путем изменения базового класса \(изменение расхода калорий всех животных во время движения\).

**Плохо:**
```javascript
class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  // ...
}
// Плохо, потому что Employee (Сотрудник) "имеет" налоговые данные.
// EmployeeTaxData (Налоговые_данные_сотрудника) не являются типом Employee (Сотрудника).
class EmployeeTaxData extends Employee {
  constructor(ssn, salary) {
    super();
    this.ssn = ssn;
    this.salary = salary;
  }
  // ...
}
```

**Хорошо:**
```javascript
class EmployeeTaxData {
  constructor(ssn, salary) {
    this.ssn = ssn;
    this.salary = salary;
  }
  // ...
}
class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  setTaxData(ssn, salary) {
    this.taxData = new EmployeeTaxData(ssn, salary);
  }
  // ...
}
```